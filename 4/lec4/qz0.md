* поток выполнения	независимая последовательность инструкций, который может выполняться с другими потоками. Обладает собственным стеком вызововов и контекстом выполнения
* стек. Причины наполнения/возврата стека(3) 	lifo-стек, хранящий информацию для возврата управления из функций/подпрограмм для воврата в основную программу.
Вложенные/рекурсивные вызовы. Обработка прерываний(в т.ч. переключение на другой процесс)
* контекст выполнения 	временная среда выполнения, инициализирующая внешние зависимости кода
* синхронный код 	очерёдное выпонение операций. Операция б начинается после завешения операции а.
* гонка данных 	несколько потоков одновременно, и поэтому непредсказуемо меняют один и тот же источник данных
* многопоточный подход многозадачности 	 программа выполняет задачи в разных потоках выполнения
* поток выполнения 	 объект ОС, часть процесса; содержит сведения об обрабатываемом коде и реализует его.
* библиотека для многопоточного выполнения 	import threading
* создаём поток 	thr = threading.Thread(target=func_name, args=(arg1,arg_n))
* выполняем поток(2)	{threading.Thread}.start() {}.join()
* выполняем несколько потоков 	ложим threading.Thread в коллекцию и проходим start,join через for
* многопроцессорный подход многозадачности 	программа выполняет код в разных процессах. Каждый процесс выполняет свою задачу независимо от других процессов; процессы могут быть развёрнуты на разных ядрах cpu/gpu
* штатный модуль многопроцессорного кода 	import multiprocessing
* разворачиваем многопроцессорный объект 	multipr_ = multiprocessing.Process( target=worker, args=(i,))
* запускаем многопроцессорный объект(2) 	multipr_.start() mulipr_.join()
* семафор 	метод синхронизации работы процессов в основе которого лежит счётчик который увеличить или уменьшить на еденицу. Уменьшить ноль нельзя - операция блокируется.
* безопасная для многопоточности переменная 	multiprocessing.Value('str_name',0)
* блокируем переменную для изменения другими процессами 	a = multiprocessing.Value('i',0) with a.get_lock(): a.value +=1
* асинхронный подход к многозадачности	в рамках одного потока, через события и обратные вызовы программа обрабатывает несколько задач
* штатная библиотека асинхронности 	import asyncio
* корутина 	фунция которая может приостанавливать своё действие, освобожая процессор для других корутин
* событие	используется чтобы уведомлять корутину, команда ждать/действовать 
* цикл событий 	 алгоритм выполнения корутин и обработки событий
* синтаксис асинхронной функции 	async def fname(): pass
* признак корутинного оператора await action(args)
* ждём асинхронно 	await asyncio.sleep(t)
* запускаем асинхронную функцию async def main(): task1 = asyncio.create_task(async_func()) await task1    asyncio.run(main())
* запускаем несколько функций однострочно 	await asyncio.gather( asyncfunc(), asyncfunc() )
* рекурсивно проходим по папке for file in Path(".").rglob('pattern'): do(file)
* рекомендуемый интерфейс для веб-запросов(aiohttp) 	aiohttp.ClientSession()
* качаем страничку асинхронно 	async with ClientSession() as cli:  async with cli.get(url) as html: return await html.text()
* asyncio, собираем пул заданий 	def main():    tasks=[]  for i in todo:  task =asyncio.ensure_future(do(i))  tasks.append(task)  await asyncio.gather(\*tasks)
* asyncio, запускаем пул заданий 	loop = asyncio.get_event_loop()  loop.run_until_complete(main())

**лекция**

* GIL 	global interpretator locker; механизм обеспечивающий последовательное, синхронное выполнение операций, избавляет от гонки чтения
* особенность многопроцессорного запуска в python( по ресурсам)	для каждого задания( в отдельном процессе) открывается своя версия интерпретатора со своим GIL. Это требует задействования большего количества ресурсов, с выиграшем в скорости
* что даёт объединение process.start() process.join() в один цикл for 	синхронное выполнение, но с делением на процессы
* как работает многопроцессорное выполнение с глобальными переменными, без multiprocessing.Value 	из основного интерпретататора копируется значение и обрабатывается отдельно.
* что делает await в асинхронном выполнении 	 высвобождает интерпретатор для других корутин
* что такое aiohhtp	асинхронная реализация requests

