* поток выполнения	независимая последовательность инструкций, который может выполняться с другими потоками. Обладает собственным стеком вызововов и контекстом выполнения
* стек. Причины наполнения/возврата стека(3) 	lifo-стек, хранящий информацию для возврата управления из функций/подпрограмм для воврата в основную программу.
Вложенные/рекурсивные вызовы. Обработка прерываний(в т.ч. переключение на другой процесс)
* контекст выполнения 	временная среда выполнения, инициализирующая внешние зависимости кода
* синхронный код 	очерёдное выпонение операций. Операция б начинается после завешения операции а.
* гонка данных 	несколько потоков одновременно, и поэтому непредсказуемо меняют один и тот же источник данных
* многопоточный подход многозадачности 	 программа выполняет задачи в разных потоках выполнения
* поток выполнения 	 объект ОС, часть процесса; содержит сведения об обрабатываемом коде и реализует его.
* библиотека для многопоточного выполнения 	import threading
* создаём поток 	thr = threading.Thread(target=func_name, args=(arg1,arg_n))
* выполняем поток(2)	{threading.Thread}.start() {}.join()
* выполняем несколько потоков 	ложим threading.Thread в коллекцию и проходим start,join через for
* многопроцессорный подход многозадачности 	программа выполняет код в разных процессах. Каждый процесс выполняет свою задачу независимо от других процессов; процессы могут быть развёрнуты на разных ядрах cpu/gpu
* штатный модуль многопроцессорного кода 	import multiprocessing
* разворачиваем многопроцессорный объект 	multipr_ = multiprocessing.Process( target=worker, args=(i,))
* запускаем многопроцессорный объект 	multipr_.start() mulipr_.join()
